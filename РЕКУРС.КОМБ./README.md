
Алгоритм Backtracking (поиск с возвратом)

Вариант 14. Реализуйте решение судоку с помощью backtracking.

Объяснение алгоритма:
1. Инициализация доски — задаём исходное поле Судоку в виде двумерного массива 9×9, где пустые клетки обозначаются нулём.
(операция: int[][] board = {...} / board[row][col] == 0)
2. Начало рекурсивного поиска — запускаем процедуру solve(board) для поиска решения.
(операция: вызов функции solve(board))
3. Поиск пустой клетки — просматриваем поле построчно и находим первую клетку со значением 0.
(операция: проверка if (board[row][col] == 0) в цикле)
4. Перебор возможных чисел — для найденной пустой клетки пробуем подставить все цифры от 1 до 9.
(операция: цикл for num in range(1, 10) / for (int num = 1; num <= 9; num++))
5. Проверка допустимости кандидата — убеждаемся, что выбранная цифра не нарушает правила Судоку:
• не повторяется в строке;
• не повторяется в столбце;
• не повторяется в соответствующем квадрате 3×3.
(операция: вызов isValid(board, row, col, num); внутри — сравнения board[row][i] == num, board[i][col] == num, вычисления блока 3*(row/3) и 3*(col/3))
6. Размещение числа — если число допустимо, временно записываем его в клетку.
(операция: присвоение board[row][col] = num)
7. Рекурсивный вызов — запускаем solve(board) снова, чтобы попытаться заполнить оставшиеся клетки.
(операция: рекурсивный вызов if (solve(board)) return true;)
8. Проверка результата рекурсии — если вложенный вызов нашёл решение, передаём успех вверх по рекурсивному стеку.
(операция: возврат true при успешном решении)
9. Возврат (backtrack) — если рекурсивный вызов не дал решения, откатываем последнее изменение, возвращая клетке значение 0.
(операция: board[row][col] = 0)
10. Попытка следующего числа — после отката пробуем следующий кандидат (следующее значение из диапазона 1–9).
(операция: продолжаем цикл for num in ...)
11. Возврат “нет решения” — если для текущей пустой клетки не подошло ни одно число, возвращаем false, сигнализируя о необходимости дальнейшего отката.
(операция: return false)
12. Завершение алгоритма — если в ходе проверки не осталось пустых клеток, решение найдено, и функция возвращает true.
(операция: return true при отсутствии клеток со значением 0)
13. Вывод результата — после успешного решения выводим заполненную таблицу.
(операция: вызов printBoard(board))

Временная сложность:

O(9ⁿ), где n — количество пустых клеток.
Каждая пустая клетка может принимать до 9 значений, и алгоритм перебирает все возможные комбинации, откатываясь при противоречии. Хотя проверки (isValid) выполняются за константное время, общее количество ветвлений растёт экспоненциально.
Ответ на вопрос: Какова временная сложность задачи о N ферзях?

Временная сложность задачи о N ферзях — экспоненциальная, то есть
O(N!)

Почему:
При решении задачи требуется расставить N ферзей на шахматной доске N \times N так, чтобы ни один не бил другого.
Если ставить по одному ферзю в каждую строку, то для первой строки есть N возможных позиций, для второй — N-1, для третьей — N-2, и так далее.
Таким образом, общее количество возможных расстановок — N!.

Поскольку алгоритм должен проверить (или перебрать) эти варианты, временная сложность пропорциональна количеству таких расстановок, то есть
O(N!)
