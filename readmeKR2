Erman-11-24 — Алгоритмы сортировки и поиска

Сортировка выбором (Selection Sort)
Определение:
Алгоритм сортировки, который последовательно выбирает наименьший (или наибольший) элемент из неотсортированной части и помещает его в конец отсортированной части.
Краткий анализ:
Простой алгоритм, понятный, но с квадратичной сложностью; часто используется в обучении.
Пример работы (консоль):
Вводные данные: [64,25,12,22,11]
Выведенные данные: [11, 12, 22, 25, 64]
Временная сложность:
Лучший: O(n^2), Средний: O(n^2), Худший: O(n^2)

Сортировка обменом (Пузырёк) (Bubble Sort)
Определение:
Алгоритм многократных проходов по массиву с обменом соседних элементов при нарушении порядка.
Краткий анализ:
Простой, понятный; эффективен только для почти отсортированных данных; стабилен.
Пример работы (консоль):
Вводные данные: [5,1,4,2,8]
Выведенные данные: [1, 2, 4, 5, 8]
Временная сложность:
Лучший: O(n), Средний: O(n^2), Худший: O(n^2)

Сортировка вставками (Insertion Sort)
Определение:
Алгоритм, который строит отсортированную последовательность, поочерёдно вставляя элементы из неотсортированной части.
Краткий анализ:
Хорош для небольших и почти отсортированных массивов; стабилен и прост в реализации.
Пример работы (консоль):
Вводные данные: [12,11,13,5,6]
Выведенные данные: [5, 6, 11, 12, 13]
Временная сложность:
Лучший: O(n), Средний: O(n^2), Худший: O(n^2) 

Сортировка слиянием (Merge Sort)
Определение:
Алгоритм 'разделяй и властвуй': делим массив, сортируем части и сливаем их.
Краткий анализ:
Гарантированно O(n log n) по времени; требует дополнительной памяти для слияния; стабильна.
Пример работы (консоль):
Вводные данные: [38,27,43,3,9,82,10]
Выведенные данные: [3, 9, 10, 27, 38, 43, 82]
Временная сложность:
Лучший/Средний/Худший: O(n log n)
 
Сортировка Шелла (Shell Sort)
Определение:
Обобщение сортировки вставками с использованием уменьшабщегося шага (gap).
Краткий анализ:
Быстрее вставок на многих входах; сложность зависит от выбранной последовательности gap.
Пример работы (консоль):
Вводные данные: [12,34,54,2,3]
Выведенные данные: [2, 3, 12, 34, 54]
Временная сложность:
Зависит от gap: часто между O(n log n) и O(n^2)
 
Быстрая сортировка (Quick Sort)
Определение:
Разделяй-и-властвуй: выбирается опорный элемент (pivot), массив разделяется на части меньших и больших элементов, рекурсивно сортируются части.
Краткий анализ:
Очень эффективна в среднем (O(n log n)), но может деградировать до O(n^2) на худших входах без рандомизации.
Пример работы (консоль):
Вводные данные: [10,7,8,9,1,5]
Выведенные данные: [1, 5, 7, 8, 9, 10]
Временная сложность:
Лучший/Средний: O(n log n), Худший: O(n^2)
 
Пирамидальная сортировка (Heap Sort)
Определение:
Построение бинарной кучи из массива, затем извлечение максимума (или минимума) и восстановление кучи.
Краткий анализ:
Гарантированная O(n log n) по времени; обычно не стабильна; можно реализовать in-place через heapify и sift-down.
Пример работы (консоль):
Вводные данные: [4,10,3,5,1]
Выведенные данные: [1, 3, 4, 5, 10]
Временная сложность:
Лучший/Средний/Худший: O(n log n) 

Последовательный поиск (Linear Search)
Определение:
Поиск элемента перебором всех элементов последовательности один за другим до нахождения совпадения или конца.
Краткий анализ:
Простой перебор; применяется для неотсортированных массивов или как базовый метод.
Пример работы (консоль):
Вводные данные: [3,5,2,9], x=9
Выведенные данные: index 3
Временная сложность:
Лучший: O(1)

Бинарный поиск (Binary Search)
Определение:
Поиск в отсортированном массиве: сравнивает целевой элемент с центральным и отбрасывает половину, где элемент не может находиться; повторяется.

Краткий анализ:
Требует отсортированного массива; быстро O(log n); важно вычислять середину безопасно в языках с переполнением.
Пример работы (консоль):
Вводные данные: [1,3,5,7,9], x=5
Выведенные данные: index 2
Временная сложность:
Лучший: O(1), Средний/Худший: O(log n)

Интерполяционный поиск (Interpolation Search)
Определение:
Усовершенствованный бинарный поиск для равномерно распределённых данных — позиция оценивается интерполяцией между концами.
Краткий анализ:
Эффективен для равномерно распределённых массивов: средняя O(log log n), худшая O(n). Требует отсортированного массива.
Пример работы (консоль):
Вводные данные: [10,20,30,40,50], x=30
Выведенные данные: index 2
Временная сложность:
Средняя: O(log log n) при равномерном распределении, Худшая: O(n)

Фибоначчи поиск (Fibonacci Search)
Определение:
Поиск, использующий числа Фибоначчи для определения позиций разделения массива; альтернатива бинарному поиску.
Краткий анализ:
Использует числа Фибоначчи для разбиения; время O(log n); интересен теоретически и в системах с ограничениями на арифметику деления.
Пример работы (консоль):
Вводные данные: [1,3,7,15,20,40], x=15
Выведенные данные: index 3
Временная сложность:
Лучший/Средний/Худший: O(log n)
