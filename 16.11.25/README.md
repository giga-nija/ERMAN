Жадный алгоритм для задачи о максимальном разрезе
Задача: реализовать жадный алгоритм для задачи о максимальном разрезе (MAX CUT).
Требования:
- Разделить вершины графа на две группы для максимизации ребер между группами
- Вывести две группы вершин и количество ребер в разрезе
Входные данные:
Граф с 8 вершинами (полный граф или граф с 15 ребрами)

Контрольный вопрос:
«Жадный алгоритм для покрытия множеств. Какой коэффициент аппроксимации имеет жадный алгоритм для задачи о покрытии множеств и почему?».

Анализ алгоритма
1. Ввод графа пользователем — функция read_graph() (строки 3–15)
Программа считывает количество вершин и рёбер, затем — список рёбер.
 2. Создание массива групп (group = [-1] * n) — строка 20
Инициализация групп перед построением разреза.
 3. Основной цикл по вершинам (for v in range(n):) — строка 23
Жадный алгоритм обрабатывает вершины последовательно.
 4. Подсчёт вкладов cut_if_0 и cut_if_1 — строки 26–41
Для вершины подсчитывается, сколько рёбер попадут в разрез при помещении в каждую группу.
 5. Жадный выбор группы (group[v] = 0 if cut_if_0 >= cut_if_1 else 1) — строка 44
Локально оптимальное решение для вершины.
 6. Подсчёт итогового разреза — строка 47
Пересчитываем количество рёбер, которые пересекают границу групп.

Временная сложность
Пусть:
 • n — число вершин,
 • m — число рёбер.
Внешний цикл — n итераций, внутренний — просмотр всех m рёбер.
Итого: O(nm)
Почему такая сложность
Алгоритм не хранит список смежности — он проверяет каждое ребро при назначении каждой вершины.
Поэтому:
 • на каждый шаг выбора вершины требуется просмотр всех рёбер,
 • это даёт произведение n \cdot m.

Ответ на контрольный вопрос
Жадный алгоритм для задачи о покрытии множеств (Set Cover)
имеет аппроксимационный коэффициент:
\boxed{\ln n + 1}
Обоснование:
На каждом шаге алгоритм выбирает множество, покрывающее максимальное количество ещё не покрытых элементов.
Анализ через гармонический ряд показывает, что решение жадного алгоритма может быть хуже оптимального не более чем в \ln n + 1 раз.
