Erman-11-24 — Алгоритмы сортировки и поиска

1. Сортировка выбором (Selection Sort)
Определение: Сортировка выбором --- это алгоритм сортировки, который работает путём многократного поиска минимального элемента из неотсортированной части массива и его обмена с первым элементом неотсортированной части.

Описание: На каждом шаге алгоритма находят минимальный элемент среди неотсортированных и меняют его местами с текущим элементом массива.

Пошаговая работа: 1. Начинаем с первого элемента массива (цикл for с индексом i). 2. Находим минимальный элемент в неотсортированной части (внутренний цикл for с индексом j и оператором сравнения arr[j] < arr[minIndex]). 3. Меняем местами найденный минимальный элемент с текущим (операция swap с использованием временной переменной temp). 4. Увеличиваем отсортированную часть на один элемент (инкремент i++). 5. Повторяем процесс для оставшейся части массива.

Сложность: O(n²) во всех случаях. Почему: Алгоритм всегда выполняет два вложенных цикла --- внешний проходит по всем элементам, внутренний ищет минимум среди оставшихся, что даёт квадратичную сложность.

Пример: Исходный массив: [23, 56, 21, 41, 12] Отсортированный массив: [12, 21, 23, 41, 56]

2. Сортировка пузырьком (Bubble Sort)
Определение: Сортировка пузырьком --- это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

Описание: Сравниваются соседние элементы и при необходимости меняются местами.

Пошаговая работа: 1. Проходим по массиву несколько раз (внешний цикл for с индексом i). 2. Сравниваем соседние элементы (оператор if с условием arr[j] > arr[j + 1]). 3. Если левый больше правого --- меняем их местами (операция swap с временной переменной temp). 4. После каждого прохода наибольший элемент всплывает в конец (уменьшение границы n - i - 1). 5. Повторяем до полной сортировки (флаг swapped с проверкой if (swapped == false)).

Сложность: Худший и средний случай: O(n²) Лучший случай (уже отсортированный массив): O(n) Почему: Алгоритм сравнивает все пары соседних элементов. В худшем случае нужно пройти n раз по n элементам (O(n²)), но если массив уже отсортирован --- достаточно одного прохода (O(n)).

Пример: Исходный массив: [64, 34, 25, 12, 22, 11, 90] Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

3. Сортировка вставками (Insertion Sort)
Определение: Сортировка вставками строит отсортированную часть массива, вставляя каждый новый элемент на правильное место.

Описание: Алгоритм вставляет каждый элемент в нужную позицию в отсортированной части.

Пошаговая работа: 1. Начинаем со второго элемента (цикл for с индексом i, начиная с i = 1). 2. Запоминаем текущий элемент (переменная key = arr[i]). 3. Сдвигаем элементы, большие текущего, вправо (цикл while с условием j >= 0 && arr[j] > key). 4. Вставляем элемент на найденную позицию (arr[j + 1] = key). 5. Повторяем для всех элементов.

Сложность: Худший и средний случай: O(n²) Лучший случай: O(n) Почему: Каждый новый элемент сравнивается со всеми элементами отсортированной части. В худшем случае это n сравнений для каждого из n элементов (O(n²)), а если массив отсортирован --- только одно сравнение на элемент (O(n)).

Пример: Исходный массив: [15, 8, 42, 4, 23, 16] Отсортированный массив: [4, 8, 15, 16, 23, 42]

4. Сортировка слиянием (Merge Sort)
Определение: Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам и объединяет отсортированные части.

Описание: Делим массив, сортируем части и объединяем.

Пошаговая работа: 1. Разделяем массив пополам (рекурсивные вызовы mergeSort(left, right)). 2. Рекурсивно сортируем левую и правую половины (вызовы mergeSort для обеих частей). 3. Объединяем отсортированные половины (функция merge с циклами while для сравнения leftArr[i] <= rightArr[j]).

Сложность: O(n log n) во всех случаях. Почему: Массив делится пополам log n раз, а на каждом уровне объединяются n элементов. Это даёт общую сложность O(n log n).

Пример: Исходный массив: [38, 27, 43, 3, 9, 82, 10] Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

5. Сортировка Шелла (Shell Sort)
Определение: Сортировка Шелла --- это усовершенствованная версия сортировки вставками, которая сравнивает элементы на определённом расстоянии.

Описание: Сравнение и перестановка элементов на определённом шаге.

Пошаговая работа: 1. Выбираем шаг (gap = n / 2). 2. Сортируем элементы с этим шагом методом вставок (цикл for с шагом gap и условием arr[j - gap] > temp). 3. Уменьшаем шаг (gap = gap / 2). 4. Завершаем сортировку с шагом 1.

Сложность: В среднем O(n log n), в худшем --- O(n²). Почему: Сортировка вставками выполняется на подмассивах, расстояние между элементами уменьшается с каждым проходом. Это ускоряет упорядочивание по сравнению с обычной вставкой, но сложность зависит от выбора последовательности шагов.

Пример: Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3] Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

6. Быстрая сортировка (Quick Sort)
Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и делит массив на части, меньшие и большие его.

Описание: Делим массив относительно опорного элемента и сортируем рекурсивно.

Пошаговая работа: 1. Выбираем опорный элемент (pivot = arr[high]). 2. Делим массив на элементы меньше и больше pivot (функция partition с циклами while и условиями arr[i] <= pivot, arr[j] > pivot). 3. Рекурсивно сортируем обе части (вызовы quickSort для левой и правой частей). 4. Объединяем результат (на месте).

Сложность: Средний случай: O(n log n) Худший случай: O(n²) Почему: Если опорный элемент делит массив примерно пополам --- глубина рекурсии log n, а на каждом уровне обрабатываются n элементов (O(n log n)). Если же pivot выбирается плохо (например, всегда крайний элемент), деление становится неравномерным, и сложность возрастает до O(n²).

Пример: Исходный массив: [24, 15, 38, 2, 19, 41, 8] Отсортированный массив: [2, 8, 15, 19, 24, 38, 41]

7. Пирамидальная сортировка (Heap Sort)
Определение: Пирамидальная сортировка использует структуру данных "куча" для упорядочивания элементов.

Описание: Строим max-кучу и извлекаем элементы по одному.

Пошаговая работа: 1. Строим max-кучу (функция buildMaxHeap с циклом for). 2. Корень кучи содержит максимальный элемент (arr[0]). 3. Меняем корень с последним элементом (операция swap). 4. Восстанавливаем кучу (функция heapify с рекурсией и сравнением arr[largest] > arr[i]). 5. Повторяем, пока куча не пуста.

Сложность: O(n log n) во всех случаях. Почему: Построение кучи выполняется за O(n), а каждая операция извлечения и восстановления кучи требует O(log n). Для n элементов --- O(n log n).

Пример: Исходный массив: [4, 10, 3, 5, 1] Отсортированный массив: [1, 3, 4, 5, 10]

Алгоритмы поиска
1. Последовательный поиск (Linear Search)
Определение: Последовательный поиск проверяет элементы массива один за другим, пока не найдёт нужный или не дойдёт до конца.

Пошаговая работа: 1. Начинаем с первого элемента (цикл for с индексом i). 2. Сравниваем каждый элемент с искомым (оператор ==). 3. Если найден --- возвращаем индекс (return i). 4. Если дошли до конца --- возвращаем -1 (return -1).

Сложность: O(n). Почему: В худшем случае алгоритм сравнивает искомый элемент со всеми n элементами массива.

Пример: Массив: [2, 5, 8, 12, 16, 23, 38, 45] Элемент 16 найден на позиции: 4

2. Бинарный поиск (Binary Search)
Определение: Бинарный поиск работает на отсортированном массиве и делит диапазон поиска пополам на каждом шаге.

Пошаговая работа: 1. Определяем левую и правую границы (left, right). 2. Находим средний элемент (mid = left + (right - left) / 2). 3. Сравниваем его с искомым (==, <, >). 4. Сужаем диапазон поиска (left = mid + 1 или right = mid - 1).

Сложность: O(log n). Почему: Каждый шаг делит диапазон поиска пополам, что требует log₂ n итераций.

Пример: Массив: [3, 7, 14, 21, 29, 33, 42, 55, 67, 78] Элемент 29 найден на позиции: 4 Элемент 7 найден на позиции: 1 Элемент 100 не найден Элемент 42 найден на позиции: 6

3. Интерполяционный поиск (Interpolation Search)
Определение: Улучшенный бинарный поиск для равномерно распределённых данных.

Пошаговая работа: 1. Вычисляем предполагаемую позицию по формуле интерполяции (pos = low + ((x - arr[low]) * (high - low)) / (arr[high] - arr[low])). 2. Сравниваем найденный элемент с искомым (оператор ==). 3. Сужаем область поиска (low = pos + 1 или high = pos - 1).

Сложность: Средний случай: O(log log n) Худший случай: O(n) Почему: Если элементы распределены равномерно, позиция быстро уточняется и поиск завершается за O(log log n). При неравномерном распределении может потребоваться проверка всех элементов --- O(n).

Пример: Массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] Элемент 60 найден на позиции: 5

4. Поиск Фибоначчи (Fibonacci Search)
Определение: Алгоритм поиска, использующий числа Фибоначчи для деления массива.

Пошаговая работа: 1. Находим число Фибоначчи ≥ длины массива (fibM). 2. Определяем позиции для сравнения (fibMMm2, fibMMm1). 3. Сравниваем элемент в точке разделения с искомым (<, >, ==). 4. Сдвигаем область поиска (обновляем числа Фибоначчи).

Сложность: O(log n). Почему: Массив делится не пополам, а по числам Фибоначчи, но количество шагов также пропорционально log n, аналогично бинарному поиску.

Пример: Массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100] Элемент 85 найден на позиции: 8
